import chalk from 'chalk'
import fs from 'fs-extra'
import path from 'path'
import prompts from 'prompts'
import ora from 'ora'
import { execSync } from 'child_process'
import { DEFAULT_CONFIG, detectTailwindPrefix as detectTailwindPrefixUtil } from '../utils/config.js'

// ============================================================================
// MYOPERATOR UI THEME FILE - Contains all CSS variables
// This is created as a separate file: src/lib/myoperator-ui-theme.css
// ============================================================================
export const MYOPERATOR_THEME_CSS = `/* myOperator UI Theme - Design System Variables
 * Auto-generated by myoperator-ui CLI
 * Do not edit directly - run 'npx myoperator-ui init' to update
 */

:root {
  /* =========================================================================
     PRIMITIVE COLORS - CSS Custom Properties
     ========================================================================= */

  /* Base */
  --color-white: #FFFFFF;
  --color-black: #000000;

  /* Neutral (Gray) */
  --color-neutral-25: #FDFDFD;
  --color-neutral-50: #FAFAFA;
  --color-neutral-100: #F5F5F5;
  --color-neutral-200: #E9EAEB;
  --color-neutral-300: #D5D7DA;
  --color-neutral-400: #A4A7AE;
  --color-neutral-500: #717680;
  --color-neutral-600: #535862;
  --color-neutral-700: #414651;
  --color-neutral-800: #252B37;
  --color-neutral-900: #181D27;
  --color-neutral-950: #0A0D12;

  /* Primary (Blue Gray) */
  --color-primary-25: #F9FAFB;
  --color-primary-50: #EBECEE;
  --color-primary-100: #C0C3CA;
  --color-primary-200: #A2A6B1;
  --color-primary-300: #777E8D;
  --color-primary-400: #5D6577;
  --color-primary-500: #343E55;
  --color-primary-600: #2F384D;
  --color-primary-700: #252C3C;
  --color-primary-800: #1D222F;
  --color-primary-900: #161A24;
  --color-primary-950: #0C0F12;

  /* Secondary (Turquoise) */
  --color-secondary-25: #F6FCFD;
  --color-secondary-50: #EAF8FA;
  --color-secondary-100: #BDEAEF;
  --color-secondary-200: #9DE0E7;
  --color-secondary-300: #71D2DB;
  --color-secondary-400: #55C9D5;
  --color-secondary-500: #2BBCCA;
  --color-secondary-600: #27ABB8;
  --color-secondary-700: #1F858F;
  --color-secondary-800: #18676F;
  --color-secondary-900: #124F55;
  --color-secondary-950: #0F3D3D;

  /* Error (Red) */
  --color-error-25: #FFFBFA;
  --color-error-50: #FEF3F2;
  --color-error-100: #FEE4E2;
  --color-error-200: #FECDCA;
  --color-error-300: #FDA29B;
  --color-error-400: #F97066;
  --color-error-500: #F04438;
  --color-error-600: #D92D20;
  --color-error-700: #B42318;
  --color-error-800: #912018;
  --color-error-900: #7A271A;
  --color-error-950: #55160C;

  /* Warning (Amber) */
  --color-warning-25: #FFFCF5;
  --color-warning-50: #FFFAEB;
  --color-warning-100: #FEF0C7;
  --color-warning-200: #FEDF89;
  --color-warning-300: #FEC84B;
  --color-warning-400: #FDB022;
  --color-warning-500: #F79009;
  --color-warning-600: #DC6803;
  --color-warning-700: #B54708;
  --color-warning-800: #93370D;
  --color-warning-900: #7A2E0E;
  --color-warning-950: #4E1D09;

  /* Success (Green) */
  --color-success-25: #F6FEF9;
  --color-success-50: #ECFDF3;
  --color-success-100: #DCFAE6;
  --color-success-200: #ABEFC6;
  --color-success-300: #75E0A7;
  --color-success-400: #47CD89;
  --color-success-500: #17B26A;
  --color-success-600: #079455;
  --color-success-700: #067647;
  --color-success-800: #085D3A;
  --color-success-900: #074D31;
  --color-success-950: #053321;

  /* Info (Blue) */
  --color-info-25: #F6F8FD;
  --color-info-50: #ECF1FB;
  --color-info-100: #C4D4F2;
  --color-info-200: #A8C0EC;
  --color-info-300: #80A3E4;
  --color-info-400: #6891DE;
  --color-info-500: #4275D6;
  --color-info-600: #3C6AC3;
  --color-info-700: #2F5398;
  --color-info-800: #244076;
  --color-info-900: #1C315A;
  --color-info-950: #182A44;

  /* =========================================================================
     SEMANTIC COLORS - Purpose-driven tokens
     ========================================================================= */

  /* Primary UI Colors */
  --semantic-primary: var(--color-primary-500);
  --semantic-primary-hover: var(--color-primary-600);
  --semantic-primary-selected: var(--color-primary-300);
  --semantic-primary-selected-hover: var(--color-primary-400);
  --semantic-primary-highlighted: var(--color-primary-700);
  --semantic-primary-surface: var(--color-primary-50);

  /* Brand Colors */
  --semantic-brand: var(--color-secondary-500);
  --semantic-brand-hover: var(--color-secondary-700);
  --semantic-brand-selected: var(--color-secondary-300);
  --semantic-brand-selected-hover: var(--color-secondary-600);
  --semantic-brand-highlighted: var(--color-secondary-600);
  --semantic-brand-surface: var(--color-secondary-50);

  /* Background Colors */
  --semantic-bg-primary: var(--color-white);
  --semantic-bg-secondary: var(--color-primary-950);
  --semantic-bg-ui: var(--color-neutral-100);
  --semantic-bg-grey: var(--color-neutral-200);
  --semantic-bg-grey-hover: var(--color-neutral-400);
  --semantic-bg-inverted: var(--color-black);
  --semantic-bg-hover: var(--color-neutral-300);

  /* Text Colors */
  --semantic-text-primary: var(--color-neutral-900);
  --semantic-text-secondary: var(--color-primary-500);
  --semantic-text-placeholder: var(--color-primary-200);
  --semantic-text-link: var(--color-info-500);
  --semantic-text-inverted: var(--color-white);
  --semantic-text-muted: var(--color-neutral-500);

  /* Border Colors */
  --semantic-border-primary: var(--color-primary-500);
  --semantic-border-secondary: var(--color-primary-300);
  --semantic-border-accent: var(--color-secondary-600);
  --semantic-border-layout: var(--color-neutral-200);
  --semantic-border-input: var(--color-neutral-200);
  --semantic-border-input-focus: var(--color-secondary-500);

  /* Disabled State */
  --semantic-disabled-primary: var(--color-primary-200);
  --semantic-disabled-secondary: var(--color-primary-50);
  --semantic-disabled-text: var(--color-neutral-500);
  --semantic-disabled-border: var(--color-neutral-300);

  /* Error State */
  --semantic-error-primary: var(--color-error-500);
  --semantic-error-surface-subtle: var(--color-error-25);
  --semantic-error-surface: var(--color-error-50);
  --semantic-error-text: var(--color-error-700);
  --semantic-error-border: var(--color-error-300);
  --semantic-error-hover: var(--color-error-600);

  /* Warning State */
  --semantic-warning-primary: var(--color-warning-500);
  --semantic-warning-surface-subtle: var(--color-warning-25);
  --semantic-warning-surface: var(--color-warning-50);
  --semantic-warning-text: var(--color-warning-700);
  --semantic-warning-border: var(--color-warning-300);
  --semantic-warning-hover: var(--color-warning-600);

  /* Success State */
  --semantic-success-primary: var(--color-success-500);
  --semantic-success-surface-subtle: var(--color-success-25);
  --semantic-success-surface: var(--color-success-50);
  --semantic-success-text: var(--color-success-700);
  --semantic-success-border: var(--color-success-300);
  --semantic-success-hover: var(--color-success-600);

  /* Info State */
  --semantic-info-primary: var(--color-info-500);
  --semantic-info-surface-subtle: var(--color-info-25);
  --semantic-info-surface: var(--color-info-50);
  --semantic-info-text: var(--color-info-700);
  --semantic-info-border: var(--color-info-200);
  --semantic-info-hover: var(--color-info-600);

  /* =========================================================================
     LEGACY SHADCN VARIABLES (for compatibility)
     ========================================================================= */
  --background: 0 0% 100%;
  --foreground: 220 20% 12%;
  --card: 0 0% 100%;
  --card-foreground: 220 20% 12%;
  --popover: 0 0% 100%;
  --popover-foreground: 220 20% 12%;
  --primary: 222 26% 27%;
  --primary-foreground: 210 40% 98%;
  --secondary: 183 64% 46%;
  --secondary-foreground: 0 0% 100%;
  --muted: 210 40% 96.1%;
  --muted-foreground: 220 9% 46%;
  --accent: 183 64% 46%;
  --accent-foreground: 0 0% 100%;
  --destructive: 4 89% 58%;
  --destructive-foreground: 0 0% 100%;
  --border: 220 13% 91%;
  --input: 220 13% 91%;
  --ring: 222 26% 27%;
  --radius: 0.5rem;
}

.dark {
  --background: 222 47% 5%;
  --foreground: 210 40% 98%;
  --card: 222 47% 5%;
  --card-foreground: 210 40% 98%;
  --popover: 222 47% 5%;
  --popover-foreground: 210 40% 98%;
  --primary: 210 40% 98%;
  --primary-foreground: 222 47% 11%;
  --secondary: 217 33% 17.5%;
  --secondary-foreground: 210 40% 98%;
  --muted: 217 33% 17.5%;
  --muted-foreground: 215 20% 65%;
  --accent: 217 33% 17.5%;
  --accent-foreground: 210 40% 98%;
  --destructive: 0 63% 31%;
  --destructive-foreground: 210 40% 98%;
  --border: 217 33% 17.5%;
  --input: 217 33% 17.5%;
  --ring: 213 27% 84%;
}
`

// ============================================================================
// MINIMAL CSS TEMPLATES - Just import theme + Tailwind directives
// ============================================================================

// Tailwind CSS v4 format - standalone (with Preflight)
const CSS_VARIABLES_V4 = `@import "tailwindcss";
@import "./lib/myoperator-ui-theme.css";

@theme {
  --color-background: hsl(0 0% 100%);
  --color-foreground: hsl(222.2 84% 4.9%);
  --color-card: hsl(0 0% 100%);
  --color-card-foreground: hsl(222.2 84% 4.9%);
  --color-popover: hsl(0 0% 100%);
  --color-popover-foreground: hsl(222.2 84% 4.9%);
  --color-primary: hsl(222.2 47.4% 11.2%);
  --color-primary-foreground: hsl(210 40% 98%);
  --color-secondary: hsl(210 40% 96.1%);
  --color-secondary-foreground: hsl(222.2 47.4% 11.2%);
  --color-muted: hsl(210 40% 96.1%);
  --color-muted-foreground: hsl(215.4 16.3% 46.9%);
  --color-accent: hsl(210 40% 96.1%);
  --color-accent-foreground: hsl(222.2 47.4% 11.2%);
  --color-destructive: hsl(0 84.2% 60.2%);
  --color-destructive-foreground: hsl(210 40% 98%);
  --color-border: hsl(214.3 31.8% 91.4%);
  --color-input: hsl(214.3 31.8% 91.4%);
  --color-ring: hsl(222.2 84% 4.9%);
  --radius: 0.5rem;
}
`

// Tailwind CSS v4 format for Bootstrap/other frameworks
// Uses selective imports (no Preflight) to avoid conflicts with Bootstrap
// Note: prefix() doesn't work with selective imports in Tailwind v4
const CSS_VARIABLES_V4_BOOTSTRAP = `/* myOperator UI - Tailwind CSS for Bootstrap projects */
/* Selective imports to avoid Preflight conflicts with Bootstrap */
@layer theme, base, components, utilities;
@import "tailwindcss/theme.css" layer(theme);
@import "tailwindcss/utilities.css" layer(utilities);
@import "./lib/myoperator-ui-theme.css";

/* Tell Tailwind to scan component files for utility classes */
@source "./components/**/*.{js,ts,jsx,tsx}";
@source "./lib/**/*.{js,ts,jsx,tsx}";
`

// Tailwind CSS v3 format (legacy)
const CSS_VARIABLES_V3 = `@import "./lib/myoperator-ui-theme.css";

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Reset Bootstrap button styles for myOperator UI components */
@layer components {
  .inline-flex[class*="rounded"],
  button.bg-\\[\\#343E55\\],
  button.bg-\\[\\#E8EAED\\],
  button.bg-transparent {
    border: none;
    box-shadow: none;
  }
}
`

export const getTailwindConfig = (prefix: string = 'tw-', hasBootstrap: boolean = false) => `/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ["class"],
  prefix: "${prefix}",${hasBootstrap ? `
  important: true,  // Required to override Bootstrap styles` : ''}
  content: [
    "./src/components/ui/**/*.{js,ts,jsx,tsx}",
    "./src/components/custom/**/*.{js,ts,jsx,tsx}",
    "./src/modules/Shadcn/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        // Legacy shadcn colors
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        // Semantic colors - Primary UI
        "semantic-primary": "var(--semantic-primary)",
        "semantic-primary-hover": "var(--semantic-primary-hover)",
        "semantic-primary-selected": "var(--semantic-primary-selected)",
        "semantic-primary-selected-hover": "var(--semantic-primary-selected-hover)",
        "semantic-primary-highlighted": "var(--semantic-primary-highlighted)",
        "semantic-primary-surface": "var(--semantic-primary-surface)",
        // Semantic colors - Brand
        "semantic-brand": "var(--semantic-brand)",
        "semantic-brand-hover": "var(--semantic-brand-hover)",
        "semantic-brand-selected": "var(--semantic-brand-selected)",
        "semantic-brand-selected-hover": "var(--semantic-brand-selected-hover)",
        "semantic-brand-highlighted": "var(--semantic-brand-highlighted)",
        "semantic-brand-surface": "var(--semantic-brand-surface)",
        // Semantic colors - Background
        "semantic-bg-primary": "var(--semantic-bg-primary)",
        "semantic-bg-secondary": "var(--semantic-bg-secondary)",
        "semantic-bg-ui": "var(--semantic-bg-ui)",
        "semantic-bg-grey": "var(--semantic-bg-grey)",
        "semantic-bg-grey-hover": "var(--semantic-bg-grey-hover)",
        "semantic-bg-inverted": "var(--semantic-bg-inverted)",
        "semantic-bg-hover": "var(--semantic-bg-hover)",
        // Semantic colors - Text
        "semantic-text-primary": "var(--semantic-text-primary)",
        "semantic-text-secondary": "var(--semantic-text-secondary)",
        "semantic-text-placeholder": "var(--semantic-text-placeholder)",
        "semantic-text-link": "var(--semantic-text-link)",
        "semantic-text-inverted": "var(--semantic-text-inverted)",
        "semantic-text-muted": "var(--semantic-text-muted)",
        // Semantic colors - Border
        "semantic-border-primary": "var(--semantic-border-primary)",
        "semantic-border-secondary": "var(--semantic-border-secondary)",
        "semantic-border-accent": "var(--semantic-border-accent)",
        "semantic-border-layout": "var(--semantic-border-layout)",
        "semantic-border-input": "var(--semantic-border-input)",
        "semantic-border-input-focus": "var(--semantic-border-input-focus)",
        // Semantic colors - Disabled
        "semantic-disabled-primary": "var(--semantic-disabled-primary)",
        "semantic-disabled-secondary": "var(--semantic-disabled-secondary)",
        "semantic-disabled-text": "var(--semantic-disabled-text)",
        "semantic-disabled-border": "var(--semantic-disabled-border)",
        // Semantic colors - Error
        "semantic-error-primary": "var(--semantic-error-primary)",
        "semantic-error-surface-subtle": "var(--semantic-error-surface-subtle)",
        "semantic-error-surface": "var(--semantic-error-surface)",
        "semantic-error-text": "var(--semantic-error-text)",
        "semantic-error-border": "var(--semantic-error-border)",
        "semantic-error-hover": "var(--semantic-error-hover)",
        // Semantic colors - Warning
        "semantic-warning-primary": "var(--semantic-warning-primary)",
        "semantic-warning-surface-subtle": "var(--semantic-warning-surface-subtle)",
        "semantic-warning-surface": "var(--semantic-warning-surface)",
        "semantic-warning-text": "var(--semantic-warning-text)",
        "semantic-warning-border": "var(--semantic-warning-border)",
        "semantic-warning-hover": "var(--semantic-warning-hover)",
        // Semantic colors - Success
        "semantic-success-primary": "var(--semantic-success-primary)",
        "semantic-success-surface-subtle": "var(--semantic-success-surface-subtle)",
        "semantic-success-surface": "var(--semantic-success-surface)",
        "semantic-success-text": "var(--semantic-success-text)",
        "semantic-success-border": "var(--semantic-success-border)",
        "semantic-success-hover": "var(--semantic-success-hover)",
        // Semantic colors - Info
        "semantic-info-primary": "var(--semantic-info-primary)",
        "semantic-info-surface-subtle": "var(--semantic-info-surface-subtle)",
        "semantic-info-surface": "var(--semantic-info-surface)",
        "semantic-info-text": "var(--semantic-info-text)",
        "semantic-info-border": "var(--semantic-info-border)",
        "semantic-info-hover": "var(--semantic-info-hover)",
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
`


export async function init() {
  console.log(chalk.bold('\n  Welcome to myOperator UI!\n'))

  const cwd = process.cwd()
  const configPath = path.join(cwd, 'components.json')

  // Check if config already exists
  let skipConfigCreation = false
  let existingConfig: Record<string, unknown> | null = null

  if (await fs.pathExists(configPath)) {
    existingConfig = await fs.readJson(configPath)

    const { action } = await prompts({
      type: 'select',
      name: 'action',
      message: 'components.json already exists. What would you like to do?',
      choices: [
        { title: 'Update missing files only (theme, CSS)', value: 'update' },
        { title: 'Overwrite everything', value: 'overwrite' },
        { title: 'Cancel', value: 'cancel' },
      ],
      initial: 0,
    })

    if (action === 'cancel') {
      console.log(chalk.yellow('  Initialization cancelled.\n'))
      process.exit(0)
    }

    skipConfigCreation = action === 'update'

    if (skipConfigCreation) {
      console.log(chalk.blue('  ℹ Keeping existing config, updating missing files...\n'))
    }
  }

  // Detect project configuration
  const packageJsonPath = path.join(cwd, 'package.json')
  let hasBootstrap = false
  let isESM = false

  let detectedTailwindVersion: 'v3' | 'v4' | null = null

  if (await fs.pathExists(packageJsonPath)) {
    const packageJson = await fs.readJson(packageJsonPath)
    // Detect Bootstrap
    hasBootstrap = !!(packageJson.dependencies?.bootstrap || packageJson.devDependencies?.bootstrap)
    // Detect ESM
    isESM = packageJson.type === 'module'

    // Detect Tailwind version from installed packages
    const tailwindDep = packageJson.dependencies?.tailwindcss || packageJson.devDependencies?.tailwindcss
    if (tailwindDep) {
      // Check if it's v4 (starts with 4 or ^4)
      if (tailwindDep.match(/^[\^~]?4/)) {
        detectedTailwindVersion = 'v4'
      } else if (tailwindDep.match(/^[\^~]?3/)) {
        detectedTailwindVersion = 'v3'
      }
    }

    // Also check for @tailwindcss/postcss which indicates v4
    if (packageJson.dependencies?.['@tailwindcss/postcss'] || packageJson.devDependencies?.['@tailwindcss/postcss']) {
      detectedTailwindVersion = 'v4'
    }

    if (hasBootstrap) {
      console.log(chalk.blue('  ℹ Bootstrap detected - will configure Tailwind to avoid conflicts\n'))
    }

    if (detectedTailwindVersion) {
      console.log(chalk.blue(`  ℹ Tailwind CSS ${detectedTailwindVersion} detected\n`))
    }
  }

  // Auto-detect paths
  const detectGlobalCss = async () => {
    const cssOptions = [
      'src/App.scss',
      'src/index.css',
      'src/styles/globals.css',
      'src/styles/index.css',
      'src/app/globals.css',
      'app/globals.css',
      'styles/globals.css',
    ]
    for (const css of cssOptions) {
      if (await fs.pathExists(path.join(cwd, css))) {
        return css
      }
    }
    return 'src/App.scss'
  }

  const detectTailwindConfig = async () => {
    const configOptions = [
      'tailwind.config.js',
      'tailwind.config.ts',
      'tailwind.config.mjs',
      'tailwind.config.cjs',
    ]
    for (const config of configOptions) {
      if (await fs.pathExists(path.join(cwd, config))) {
        return config
      }
    }
    return 'tailwind.config.js'
  }

  const detectedCss = await detectGlobalCss()
  const detectedTailwindConfig = await detectTailwindConfig()
  const detectedPrefix = await detectTailwindPrefixUtil(detectedTailwindConfig, cwd)

  // Show prefix detection message
  if (detectedPrefix) {
    console.log(chalk.blue(`  ℹ Tailwind prefix "${detectedPrefix}" detected - components will use prefixed classes\n`))
  }

  // Get user preferences - only ask if not auto-detected
  let tailwindVersion = detectedTailwindVersion
  let userPrefix = detectedPrefix

  const questions: prompts.PromptObject[] = []

  if (!tailwindVersion) {
    questions.push({
      type: 'select',
      name: 'tailwindVersion',
      message: 'Which Tailwind CSS version are you using?',
      choices: [
        { title: 'Tailwind CSS v4 (latest)', value: 'v4' },
        { title: 'Tailwind CSS v3', value: 'v3' },
      ],
      initial: 0,
    })
  }

  // Only ask for prefix when not in update mode
  if (!skipConfigCreation) {
    questions.push({
      type: 'text',
      name: 'prefix',
      message: detectedPrefix
        ? `Confirm Tailwind prefix (detected: "${detectedPrefix}"):`
        : 'Enter Tailwind CSS prefix (default: tw-):',
      initial: detectedPrefix || 'tw-',
      validate: (value: string) => {
        // Allow empty string or valid CSS identifier
        if (value === '' || /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(value)) {
          return true
        }
        return 'Prefix must be a valid CSS identifier (letters, numbers, hyphens, underscores)'
      }
    })
  }

  if (questions.length > 0) {
    const response = await prompts(questions)
    if (!tailwindVersion) {
      tailwindVersion = response.tailwindVersion
    }
    userPrefix = response.prefix || ''
  }

  // Use detected/default paths
  const componentsPath = 'src/components/ui'
  const utilsPath = 'src/lib/utils.ts'
  const tailwindConfig = detectedTailwindConfig
  const globalCss = detectedCss

  const spinner = ora('Initializing project...').start()

  try {
    // Create config (skip if updating)
    if (!skipConfigCreation) {
      const config = {
        ...DEFAULT_CONFIG,
        tailwind: {
          ...DEFAULT_CONFIG.tailwind,
          config: tailwindConfig,
          css: globalCss,
          prefix: userPrefix,
        },
        aliases: {
          ...DEFAULT_CONFIG.aliases,
          ui: `@/${componentsPath.replace('src/', '')}`,
        },
      }

      await fs.writeJson(configPath, config, { spaces: 2 })
    } else if (existingConfig) {
      // In update mode, use prefix from existing config
      const existingTailwind = existingConfig.tailwind as Record<string, unknown> | undefined
      userPrefix = (existingTailwind?.prefix as string) || ''
    }

    // Create utils file or add cn function if missing
    const utilsFullPath = path.join(cwd, utilsPath)

    // Generate utils content based on prefix - configures tailwind-merge to understand prefixed classes
    const getCnUtilsContent = (prefix: string) => {
      if (prefix) {
        return `import { type ClassValue, clsx } from "clsx"
import { extendTailwindMerge } from "tailwind-merge"

// Configure tailwind-merge to understand the "${prefix}" prefix
const twMerge = extendTailwindMerge({
  prefix: "${prefix}",
})

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
`
      }
      // No prefix - use standard twMerge
      return `import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
`
    }

    const cnUtilsContent = getCnUtilsContent(userPrefix)
    let utilsCreated = false
    let utilsUpdated = false

    if (!(await fs.pathExists(utilsFullPath))) {
      // File doesn't exist - create it with full content
      await fs.ensureDir(path.dirname(utilsFullPath))
      await fs.writeFile(utilsFullPath, cnUtilsContent)
      utilsCreated = true
    } else {
      // File exists - check if cn function is present
      const existingUtils = await fs.readFile(utilsFullPath, 'utf-8')
      const hasCn = existingUtils.includes('export function cn') || existingUtils.includes('export const cn')

      if (!hasCn) {
        // cn function missing - need to add it with proper imports
        let updatedContent = existingUtils

        // Check and add missing imports at the top
        const hasClsxImport = existingUtils.includes('from "clsx"') || existingUtils.includes("from 'clsx'")
        const hasTwMergeImport = existingUtils.includes('from "tailwind-merge"') || existingUtils.includes("from 'tailwind-merge'")
        const hasExtendTwMerge = existingUtils.includes('extendTailwindMerge')

        let importsToAdd = ''
        if (!hasClsxImport) {
          importsToAdd += `import { type ClassValue, clsx } from "clsx"\n`
        }
        if (!hasTwMergeImport && !hasExtendTwMerge) {
          // Add the appropriate import based on prefix
          if (userPrefix) {
            importsToAdd += `import { extendTailwindMerge } from "tailwind-merge"\n`
          } else {
            importsToAdd += `import { twMerge } from "tailwind-merge"\n`
          }
        }

        // Add imports at the top if needed
        if (importsToAdd) {
          updatedContent = importsToAdd + updatedContent
        }

        // Add cn function at the end (with prefix configuration if needed)
        let cnFunction: string
        if (userPrefix) {
          cnFunction = `
// Configure tailwind-merge to understand the "${userPrefix}" prefix
const twMerge = extendTailwindMerge({
  prefix: "${userPrefix}",
})

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
`
        } else {
          cnFunction = `
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
`
        }
        updatedContent = updatedContent.trimEnd() + '\n' + cnFunction

        await fs.writeFile(utilsFullPath, updatedContent)
        utilsUpdated = true
      } else if (hasCn && userPrefix && !existingUtils.includes('extendTailwindMerge')) {
        // cn exists but is not prefix-aware — replace with correct version
        await fs.writeFile(utilsFullPath, cnUtilsContent)
        utilsUpdated = true
      }
    }

    // Create components directory
    const componentsFullPath = path.join(cwd, componentsPath)
    await fs.ensureDir(componentsFullPath)

    // Create theme file with all CSS variables (separate file for cleaner App.scss)
    const themeFilePath = path.join(cwd, 'src/lib/myoperator-ui-theme.css')
    let themeCreated = false
    if (!(await fs.pathExists(themeFilePath))) {
      await fs.ensureDir(path.dirname(themeFilePath))
      await fs.writeFile(themeFilePath, MYOPERATOR_THEME_CSS)
      themeCreated = true
    } else {
      // Check if theme file needs update (missing semantic variables)
      const existingTheme = await fs.readFile(themeFilePath, 'utf-8')
      const extractVars = (css: string) => new Set(
        [...css.matchAll(/--[\w-]+\s*:/g)].map((m) => m[0].replace(/\s*:$/, ''))
      )
      const templateVars = extractVars(MYOPERATOR_THEME_CSS)
      const existingVars = extractVars(existingTheme)
      const isMissingVars = [...templateVars].some((v) => !existingVars.has(v))
      if (isMissingVars) {
        await fs.writeFile(themeFilePath, MYOPERATOR_THEME_CSS)
        themeCreated = true
      }
    }

    // Create or update global CSS with CSS variables
    const globalCssPath = path.join(cwd, globalCss)
    // Use Bootstrap version when Bootstrap detected to avoid Preflight conflicts
    let cssContent: string
    if (tailwindVersion === 'v4') {
      cssContent = hasBootstrap ? CSS_VARIABLES_V4_BOOTSTRAP : CSS_VARIABLES_V4
    } else {
      cssContent = CSS_VARIABLES_V3
    }
    let cssUpdated = false
    if (!(await fs.pathExists(globalCssPath))) {
      await fs.ensureDir(path.dirname(globalCssPath))
      await fs.writeFile(globalCssPath, cssContent)
      cssUpdated = true
    } else {
      // Check if CSS file imports the theme file
      const existingCss = await fs.readFile(globalCssPath, 'utf-8')
      const hasThemeImport = existingCss.includes('myoperator-ui-theme.css')

      if (!hasThemeImport) {
        // Theme import missing - need to update
        spinner.stop()
        const result = await prompts({
          type: 'confirm',
          name: 'updateCss',
          message: `${globalCss} is missing myOperator UI theme import. Update?`,
          initial: true,
        })
        spinner.start('Initializing project...')

        if (result.updateCss) {
          // Replace the CSS content entirely to ensure all variables are present
          // But preserve any custom imports at the end (like Bootstrap imports)
          const customImports = existingCss.match(/@import\s+["'][^"']+["'];?\s*$/gm) || []
          const importsToKeep = customImports.filter(imp =>
            !imp.includes('tailwindcss') &&
            !imp.includes('@tailwind')
          ).join('\n')

          if (importsToKeep) {
            await fs.writeFile(globalCssPath, cssContent + '\n' + importsToKeep + '\n')
          } else {
            await fs.writeFile(globalCssPath, cssContent)
          }
          cssUpdated = true
        }
      }
    }

    // Create or update tailwind.config.js with theme colors (only for v3)
    let tailwindUpdated = false
    if (tailwindVersion === 'v3' && tailwindConfig) {
      const tailwindConfigPath = path.join(cwd, tailwindConfig)
      if (!(await fs.pathExists(tailwindConfigPath))) {
        await fs.writeFile(tailwindConfigPath, getTailwindConfig(userPrefix, hasBootstrap))
        tailwindUpdated = true
      } else {
        // Check if tailwind config already has the theme colors and semantic colors
        const existingConfig = await fs.readFile(tailwindConfigPath, 'utf-8')
        const hasLegacyColors = existingConfig.includes('hsl(var(--destructive))') || existingConfig.includes('hsl(var(--ring))')
        const hasSemanticColors = existingConfig.includes('semantic-text-primary')

        if (!hasLegacyColors && !hasSemanticColors) {
          // Config missing both - auto-update for v3
          await fs.writeFile(tailwindConfigPath, getTailwindConfig(userPrefix, hasBootstrap))
          tailwindUpdated = true
        } else if (hasLegacyColors && !hasSemanticColors) {
          // Has legacy colors but missing semantic colors - prompt to update
          spinner.stop()
          const result = await prompts({
            type: 'confirm',
            name: 'updateTailwind',
            message: `${tailwindConfig} is missing semantic color tokens. Update with full color set?`,
            initial: true,
          })
          spinner.start('Initializing project...')

          if (result.updateTailwind) {
            await fs.writeFile(tailwindConfigPath, getTailwindConfig(userPrefix, hasBootstrap))
            tailwindUpdated = true
          }
        }
      }
    }

    // Create or update postcss.config.js
    const postcssConfigPath = path.join(cwd, 'postcss.config.js')
    // Use ESM or CommonJS syntax based on project type
    // v3 uses tailwindcss + autoprefixer, v4 uses @tailwindcss/postcss
    let postcssConfigContent: string
    if (tailwindVersion === 'v4') {
      postcssConfigContent = isESM
        ? `export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
}
`
        : `module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
  },
}
`
    } else {
      // Tailwind v3 uses the classic postcss plugins
      postcssConfigContent = isESM
        ? `export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
`
        : `module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
`
    }

    let postcssCreated = false
    if (!(await fs.pathExists(postcssConfigPath))) {
      await fs.writeFile(postcssConfigPath, postcssConfigContent)
      postcssCreated = true
    } else if (tailwindVersion === 'v4') {
      // Only ask about @tailwindcss/postcss for v4 - v3 uses standard tailwindcss plugin
      spinner.stop()
      const { updatePostcss } = await prompts({
        type: 'confirm',
        name: 'updatePostcss',
        message: 'postcss.config.js exists. Update to use @tailwindcss/postcss (required for v4)?',
        initial: true,
      })
      spinner.start('Initializing project...')

      if (updatePostcss) {
        await fs.writeFile(postcssConfigPath, postcssConfigContent)
        postcssCreated = true
      }
    }
    // For v3, keep existing postcss.config.js - no changes needed

    // Install required dependencies automatically
    spinner.text = 'Installing dependencies...'
    const deps = tailwindVersion === 'v4'
      ? 'clsx tailwind-merge class-variance-authority @radix-ui/react-slot lucide-react'
      : 'clsx tailwind-merge class-variance-authority @radix-ui/react-slot lucide-react tailwindcss-animate tailwindcss@^3.4.0 autoprefixer'

    try {
      execSync(`npm install ${deps}`, { cwd, stdio: 'pipe' })
      console.log(chalk.green('\n  ✓ Installed dependencies'))
    } catch {
      // If npm install fails, we'll show manual instructions
      spinner.warn('Could not install dependencies automatically')
      console.log(chalk.yellow(`\n  Required dependencies:`))
      console.log(chalk.cyan(`    npm install ${deps}\n`))
    }

    spinner.succeed(skipConfigCreation ? 'Project updated successfully!' : 'Project initialized successfully!')

    if (!skipConfigCreation) {
      console.log(chalk.green('\n  ✓ Created components.json'))
    } else {
      console.log(chalk.green('\n  ✓ Using existing components.json'))
    }
    if (userPrefix) {
      console.log(chalk.blue(`    ℹ Components will use prefix: "${userPrefix}"`))
    } else {
      console.log(chalk.blue(`    ℹ Components will use no prefix`))
    }
    if (utilsCreated) {
      console.log(chalk.green(`  ✓ Created ${utilsPath}`))
    } else if (utilsUpdated) {
      console.log(chalk.green(`  ✓ Added cn() function to ${utilsPath}`))
    } else {
      console.log(chalk.green(`  ✓ ${utilsPath} already has cn() function`))
    }
    console.log(chalk.green(`  ✓ Created ${componentsPath}`))
    if (themeCreated) {
      console.log(chalk.green(`  ✓ Created src/lib/myoperator-ui-theme.css (CSS variables)`))
    }
    if (cssUpdated) {
      console.log(chalk.green(`  ✓ Updated ${globalCss} with theme import`))
    }
    if (tailwindUpdated) {
      console.log(chalk.green(`  ✓ Updated ${tailwindConfig} with theme colors`))
    }
    if (postcssCreated) {
      console.log(chalk.green('  ✓ Created postcss.config.js'))
    }
    console.log('')

    console.log(chalk.bold('  Next steps:\n'))
    console.log('  1. Add your first component:')
    console.log(chalk.cyan('     npx myoperator-ui add button\n'))
    console.log('  2. Browse all components:')
    console.log(chalk.cyan('     https://myoperator-ui.vercel.app\n'))
  } catch (error) {
    spinner.fail('Failed to initialize project')
    console.error(error)
    process.exit(1)
  }
}
